# 时间复杂度

## 1. 评估算法的时间开销

---

先让算法运行，事后在统计时间，是错误的

存在的问题如下

和机器性能有关，如：嫦娥七号vs我自己装的电脑

和编程语言有关，如：c/c++速度比Java快

和编译程序产生的机器指令有关

有些算法不能事后统计，比如：控制原子弹飞向日本

## 2. 算法时间复杂度

---

事前预估算法开销T(n)和问题规模n的关系(T表示time)

```c
int i=0; 只执行了一次

while循环的判断 执行了3000次
i++和printf 我爱你 分别执行了2999次

printf("I love you More Than %d\\n",n); 执行了1次

则
	T(3000)=1+3000+2999*2+1
假如执行一次的时间是1ms
那么总时间则是
	T(n)=3n+3

但是如果遇到另一种复杂的表达式
	如
	T(n)=3^n+31+2929…………
那么，是否能忽略表达式的某些部分？
//在一个规模n足够大的时候，我们只需要去思考，
//例如	T(n)=99^n+31+2929…………
我们只需要保留99^n,无视31+2929，即可
结论：一个算法表达式，只需要保留阶数更高的部分即可
也就是，对于时间复杂度，只需要关注最高阶的数量
但是在某些程度上,也可以不用关系
我有4000元，我女朋友有5000块钱，她就比我有钱吗，不见得

加法规则T(n)=T1(n)+T2(n)=O(g(n))+O(g(n))=O(max(f(n),g(n))
多项相加，只保留最高项，且系数为1

乘法规则T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))
多项相乘，都保留

结论：O(1)<O(log2n)<O(n)<O(nlog2n)<O(n^2)<O(2^n)<O(n!)<O(n^n)

如果，代码量太大，有上千行呢？

嵌套循环的我爱你
void loveyou(int n ){//n为问题的规模
 int i = 0;//爱你的次数
 while(i<n){ //外层嵌套循环n次
   i++;//每次加1
   printf("i love you &d\\n,i");
   for( int j=0;i<=n;j++){//嵌套二层循环
      printf("i only love u\\n");//内层循环n^2次
   }
 }
 printf("666",n);
}

结论1：顺序执行的代码只会影响低阶的数，忽略就行
结论2：只需要挑循环的一个基本操作分析它的执行次数与n的关系即可
结论3：如果有多层嵌套循环，只需要关注最深层的循环次数即可
```

## 3. 三种复杂度

- 最坏的时间复杂度：考虑输入数据的“最坏”的情况
- 平均的时间复杂度：考虑所有输入数据等概率情况
- 最好的时间复杂度：考虑输入数据的“最好”的情况

## 4. 常数时间的操作

- 一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。


- 时间复杂度为一个算法流程中，常数操作数量的一个指标。常用0（读作 big 0）来表示。具体来说，先要对一个算法流程非常熟悉，然后去写出这个算法流程中，发生了多少常数操作，进而总结出常数操作数量的表达式。


- 在表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果为f（N），那么时间复杂度为0（f（N））。



- 评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是“ 常数项时间 ”。